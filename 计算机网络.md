# 计算机网络

## 概述

### 分组交换与电路交换

#### 分组交换

+ **存储转发基础**:交换机在想输出链路传输某个分组的第一比特时，必须收到整个分组
+ **排队时延与分组丢失**：分组交换机有输出缓存，当到达的分组要输出时，链路正在输出其他分组，那么分组就要在输出缓存中等待，等待时长就是排队时延，当缓存充满，某些分组可能会被丢弃，称为分组丢失
+ **转发表与路由选择协议**：每台路由器都有一个转发表，用于把分组的目标地址映射为输出链路。分组到达路由器时，路由器检查目的地址与转发表。
+ **时延**:
  + 处理时延(processing delay):路由器检查分组的首部和目的地所用的时间
  + 排队时延(queuing delay):分组在交换机上等待被传输所用的时间
  + 传输时延(transmission delay):交换机把分组推向链路所用的时间（可以理解为“发射”所用的时间），分组长度为L，传输速率为R，则传输时延为L/R
  + 传播时延(propagation delay):分组从链路起点到链路终点所用的时间，取决于链路的物理性质
  + 端到端时延：N*(处理时延+排队时延+传输时延+传播时延)  N为链路数量

#### 电路交换

+ 端到端系统中的每两台终端之间都会有直接的链接
+ 网络复用
  + 频分复用(FDM):把频率分为不同频段供不同链接使用
  + 时分复用(TDM):把时间划为帧，供不同频段使用

### 协议层次

1. 应用层

   应用层的协议有HTTP、SMTP、FTP等

   应用层的信息分组称为**报文**(message)

2. 运输层

   运输层的协议有TCP和UDP

   运输层的信息分组称为**报文段**(segment)

3. 网络层

   网络层的协议有IP

   网络层的信息分组称为**数据报**(datagram)

4. 链路层

   链路层的例子有以太网、Wi-Fi和电缆接入等

   链路的信息分组称为**帧**(frame)

5. 物理层

## 应用层

### 应用层协议原理

#### 常见体系

+ 客户-服务器结构：常见于Web和电子邮件等，一台主机作为服务器，服务来自于客户的主机请求，客户间通信需要通过服务器，需要配置强大的服务器和数据中心
+ P2P体系结构：主机间直接通信，常见于P2P下载等

#### 运输层协议提供的服务

+ 可靠数据传输
+ 吞吐量
+ 定时
+ 安全性

#### 因特网提供的运输层协议

+ TCP
+ UDP

### Web与HTTP

HTTP采用TCP作为支撑的运输层协议

#### 持续连接与非持续连接

+ 持续连接：所有的请求与相应都使用同一个TCP发送

+ 非持续链接：每个请求与相应均使用一个单独的TCP发送

#### HTTP报文格式

+ 请求报文

  ![20181012111654560](pictures\20181012111654560.png)

  + 请求行：包含了请求方法(如GET、POST等)、URL字段与协议版本
  + 首部行：包含了一系列的字段名和对应的值，如Host与User-agent等
  + 实体体：包含了请求的数据，常在使用POST方法时用到

+ 响应报文

  ![20181012172656929](pictures\20181012172656929.png)

  + 状态行：包含了HTTP，协议版本与状态字段和相应的状态 
  + 首部行：包含了一系列的字段名与对应的值，如Connection、Date、Server等
    + Connection
    + Date
    + Serve
    + Last-Modified
    + Content-Type

#### Cookie

常用的cookie包含以下四个部分

+ HTTP请求报文中的字段
+ HTTP响应报文中的字段
+ 用户本地的cookie文件
+ 位于Web服务器的cookie数据库

#### Web Cache

Web Cache也叫代理服务器，用来存储用户最近请求过的对象的副本

流程：

+ 浏览器创建一个到Web缓存的TCP链接，香气中的对象发送一个HTTP请求
+ Web缓存检查是否保存了用户请求对象的副本，如果有则发送HTTP响应报文返回对象
+ 如果没有，则Web缓存器建立一个到初始服务器的TCP链接，并向其发送一个HTTP请求，初始服务器向Web缓存器发送包含该对象的HTTP响应
+ Web缓存既向用户通过HTTP响应报文发送该对象，又在cache保存一份该对象的副本

条件GET方法：

为了避免用户在Web Cache访问到的对象是陈旧的，用户可以在HTTP请求中使用条件GET，应用If-Modified-Since字段来请求自某事件以后的最新版本的对象

### 电子邮件

互联网电子邮件主要有以下三个组成部分：

+ 用户代理
+ 邮件服务器
+ 简单邮件传输协议(SMTP,Simple Mail Transfer Protocol)

#### SMTP操作：

+ 某用户的用户代理把邮件 发给其邮件服务器
+ 运行在邮件服务器的SMTP客户端发现了邮件，于是创建一个到目标用户邮件服务器的TCP连接
+ 经过SMTP握手，SMTP客户端通过该TCP链接发送邮件
+ 目标用户的邮件服务器收到邮件，用户可通过用户代理来阅读邮件

#### 与HTTP的对比

+ HTTP属于拉协议，而SMTP属于推协议
+ SMTP要求邮件以7比特ASCII编码，非7比特ASCII内容如图像也要按照此规则编码，HTTP无要求
+ 对于一个既含文本也含图形的文档，HTTP把每个对象都封装到HTTP响应报文中，而SMTP把这些放在一个报文中

#### 邮件报文格式

+ 首部行：包含FROM字段、TO字段与其他字段
+ 内容体：邮件内容

#### 邮件访问协议

+ POP3(第三版邮局协议 , Post Office Protocol Version 3）
+ IMAP(因特网邮件访问协议 , Internet Mail Access Protocol)
+ HTTP

### DNS(Domain Name System)

运行于UDP协议上，使用53号端口 

提供的服务

+ 主机名到IP地址的转换
+ 主机别名
+ 邮件服务器别名
+ 负载分配

#### DNS工作机制

+ 分布式DNS服务器
  + 根DNS服务器
  + 顶级域DNS服务器（TLD DNS）(例如com、cn、gov等)
  + 权威DNS服务器
  + 本地DNS服务器
+ 工作机制
  + 当用户主机请求一个域名的IP地址时，首先向本地DNS服务器发送请求，当本地DNS服务器没有记录时，转向上一级DNS服务器如根DNS服务器或者TLD DNS服务器，这些服务器会转向相关机构的权威DNS服务器，权威服务器返回准确的IP地址，本地DNS服务器保存记录

#### DNS记录与报文格式

+ DNS记录 格式为(Name,Value,Type,TTL)
  + Type=A,则Name为主机名，Value为对应的主机IP地址
  + Type=NS，则Name为域，Value为如何获得该域内主机的权威服务器的主机名
  + Type=CNAME，则Value是别名为Name主机的  的规范主机名
  + Type=MX，则Value是别名为Name的邮件服务器的规范主机名
  
+ DNS报文格式

  ![6-1911111G20QV](D:\SystemDefault\Documents\Desktop\计网复习\pictures\6-1911111G20QV.gif)

  + 前六个字段(12字节)为首部区域
  + 查询问题区域包含了查询信息：主机名(Name)与类型(Type)
  + 回答问题区域则包含了对请求主机名的IP地址(Value)，可能会有多个

### **P2P**

#### 分发时间

文件大小为F，要获得文件的对等方数量为N，u为上传速率、d为下载速率

+ 客户-服务器结构

  传输时间为max{NF/us，F/min(d)}

+ P2P结构

  传输时间为max{F/us，F/min(d)，NF/(us+u1+u2+···+un)}

### 内容分发网(Content Distribution Network)

#### HTTP流与DASH

+ 视频只是HTTP服务其中一个普通的文件，但所有客户收到相同编码的视频
+ DASH(Dynamic Adaptive Streaming over HTTP,经HTTP的动态适应性流)，视频编码为不同的版本，客户可以动态的请求不同编码流的版本

#### CDN操作

1. 用户访问某视频流网站，并点击一个视频
2. 用户主机发送了一个DNS请求
3. 本地DNS服务器把请求发送至该网站的权威DNS服务器，该权威DNS服务器返回CDN方的主机名
4. DNS请求被发送至CDN方的DNS服务器，该DNS服务器返回用户请求视频的IP地址
5. 用户主机与视频的IP地址建立TCP连接



## 运输层

### 多路复用与多路分解

+ 多路分解(demultiplexing)：把运输层报文段中的数据交付到正确的套接字
+ 多路复用(multiplexing)：从不同套接字中收集数据，并为不同数据块加上首部信息生成报文段，并把报文段传递到网络层

### UDP

#### UDP的特点

+ 无连接的
+ 首部开销较小，只有8字节的首部
+ 常用UDP的应用有远程文件服务器(NFS)、DNS等

#### UDP报文段结构

![6-1911111249535K](pictures\6-1911111249535K.gif)

校验和

三个16比特的字以二进制的形式相加，如果有溢出，就要回卷，最后把和取反，即为校验和

### 可靠数据传输(Reliable Data Transfer)

#### 可靠数据传输协议

##### RDT1.0

底层信道完全可靠，不会发送错误，也不会丢失分组

![rdt1.0](D:\SystemDefault\Documents\Desktop\计网复习\pictures\rdt1.0.png)

##### RDT2.0

引入ACK(Acknowledgment)与NAK(Negative Acknowledgment )

ACK表示接收方告诉发送方分组已经被正确接收

NCK表示接收方高速发送方分组错误

![rdt2.0](D:\SystemDefault\Documents\Desktop\计网复习\pictures\rdt2.0.png)

发送方收到ACK，则发送完成，若收到NAK，则重传分组，并等待接收方发送ACK或NAK

接收方收到没有受损的分组，则发送ACK，反之则发送NAK

##### RDT2.1

考虑到ACK与NAK可能会发生错误，发送方为每个分组添加序号，接收方丢弃重复的分组

![rdt2.1sender](pictures\rdt2.1sender.png)

​                                                                                                         发送方

![rdt2.1receiver](pictures\rdt2.1receiver.png)

​                                                                                                          接收方

##### RDT3.0

引入了倒计时，即发送方每一次发送分组时(不论是第一次发送还是重传)，都会启动一个倒计时，当超时时(不论是分组丢失，还是ACK/NAK丢失/超时)，发送方就会重新发送该分组

![rdt3.0sender](pictures\rdt3.0sender.png)

​                                                                                                  发送方

###### 几种可能出现的情况

+ 无丢包操作
+ 分组丢失![a](pictures\a.png)
+ 丢失ACK
+ 过早超时![b](pictures\b.png)

#### 流水线可靠数据传输协议

停等协议的利用率较低，所以采取以下措施

+ 增加序号范围
+ 发送方与接收方可以缓存分组

#### 回退N步(GBN)

协议有一个长度为N的窗口，窗口内的包都可以发送，每次发送一个包，都会开始倒计时

+ GBN中，接收方丢弃所有的失序分组，即若第n个包丢失，接受方未接受到第n个包，即使接收方接收到了第n+1个包，也只会返回ACK n-1，即告诉发送方只正确接收了前n-1个包

+ 当发送方接收到了ACK n，发送方就认为前n个包全部被正确接收

#### 选择重传(SR)

+ SR中，接收方不会丢弃失序分组，而是将其缓存起来，直到序号更小的丢失分组被接受到，不会失序，从而确认这些分组。若第n个分组丢失，接收方却接收到了第n+1个包，也会返回ACK n+1，但却把第n+1个包缓存起来，窗口也不会向前滑动，直到正确的接收到了第n个包，才会把第n和第n+1个包标记为接收
+ 当发送方未接受到ACK n，却接收到了ACK n+1，也不会认为第n个包被正确接受，而是在超时后重传这个包，收到ACK后窗口才向前滑动



### TCP

#### 概述

+ 面向连接的：在进程开始向另一进程发送消息前，必须发送某些预备报文段，确保数据传输。

  握手的流程

  + 客户发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，客户再用第三个特殊TCP报文段响应
  + 前两个报文段没有有效载荷(应用层数据)，第三个报文段包含了有效载荷
  + 这种过程称为三次握手

+ 全双工(full-duplex)：应用层数据可从进程A到B，也可以从B到A

+ TCP链接引导数据到发送缓存(send buffer)中，TCP从发送缓存中取出并放入报文段的数据大小取决于最大报文段长度(Maximum Segment Size , MSS)，而MSS的大小则取决于最大链路层帧长度(Maximum Transmission Unit , MTU)。这种设置要保证单个链路层帧要包含一个TCP报文段加上TCP/IP首部长度(通常为40字节)

+ TCP为每块数据加上TCP首部，从而构成了TCP报文段

#### TCP报文段结构

![TCP](pictures/TCP.png)

+ 源端口号与目的端口号，用于多路复用与多路分解
+ 序号与确认号字段，用于可靠数据传输
+ 首部长度字段，由于选项字段的存在，TCP首部长度是可变的，但通常选项字段为空，TCP首部长度为20字节
+ 6bit的标志字段
  + ACK位表示确认号字段中的值是有效的
  + RST、SYN、FIN位用于连接的建立与拆除
  + PSH位置位表示接收方应立即把数据交给上层
  + URG位表示报文段里存在被发送端上层置为“紧急”的数据
+ 窗口大小：用于流量控制
+ 校验和字段：同UDP
+ 紧急指针字段：指出紧急数据的最后一位

#### 往返时间估计与超时

平均往返时间：EstimateRTT=(1-a) · EstimateRTT + a · SampleRTT                                                            a的推荐值为0.125

SampleRTT对EstimateRTT的偏离程度：DevRTT=(1-b) · DevRTT + b · |SampleRTT-EstimateRTT|       b的推荐值为0.25

超时间隔：TimeoutInterval=EstimateRTT + 4 · DevRTT                                                                             TimeoutInterval的推荐初始值为1s

#### 可靠数据传输

由于IP协议的不可靠性，TCP使用了可靠数据传输服务

流程如下

+ 从应用层接收到数据
+ 生成具有序号a的报文段
+ 向IP发送报文段并启动定时器，超时时长为TimeoutInterval
+ 如果定时器超时，则重传具有最小序号但未收到ACK的报文段，并重启定时器
+ 如果收到ACK(包含了有效ACK的报文段)，把ACK序号与最小序号且未确认的报文段序号比较。由于TCP采用累计确认，表示比ACK序号小的所有报文段均被确认。如果当前有未被确认的报文段，则重启定时器。

#### 流量控制

发送方维护一个称作接收窗口(receive window ,rcwd)的变量，用来告诉发送方接收方还有多少可用空间

接收方定义以下两个变量：

+ LastByteRead：接收方的应用层进程从缓存中读出的数据的最后一个字节的编号
+ LastByteRcvd：从网络层到达并存入接收方的接收缓存的数据的最后一个字节的编号

则必须要满足LastByteRcvd-LastByteRead≤RcvBuffer

接收窗口rcwd=RcvBuffer-(LastByteRcvd-LastByteRead)

接收方方把当前rcwd的值(初始值为RcvBuffer)放入它发送给发送方的报文段的接收窗口字段中

发送方定义以下两个变量：

+ LastByteSent：发送方发送的数据的最后一个字节的编号
+ LastByteAcked：发送方收到ACK的数据的最后一个字节的编号

则必须要满足：LastByteSent-LastByteAcked≤rcwd



当接收方把rcwd=0的信息告诉发送方后，发送方任要发送只有一个字节的报文段，被接收方确认后，缓存开始清空，并在确认报文里返回一个非0的rcwd值



#### TCP连接管理

![client](pictures/client.png)

客户端状态

![server](pictures/server.png)

服务端状态

##### 连接建立(三次握手)

1. 客户端向服务端发送一个特殊的TCP报文段，不包含任何数据，但SYN位被置为1，客户端也会随机的选择一个初始序号(client_isn)，这个报文段称为TCP SYN报文段，被封装到IP数据报中发送
2. 服务端收到了IP数据报并且提取TCP SYN报文段，为该TCP连接分配相关缓存与变量。服务端返回一个特殊的TCP报文段，不包含任何数据，SYN位被置为1，确认号字段为client_isn+1，服务器选择初始序号(server_isn)，这个报文段被称为TCP ACK报文段，被封装到IP数据报中发送
3. 客户端收到TCP ACK报文段后，也为该TCP连接分配相关的缓存与变量。客户端向服务端发送包含应用层数据的TCP报文段，该报文段的序号为client_isn+1,确认号为server_isn+1

##### 连接关闭(四次挥手)

1. 客户端向服务端发送一个特殊的TCP报文段，不包含任何数据，FIN位被置为1，序号为之前已经传输过最后一个字节的编号加一(u),确认号为之前收到的最后一个字节的编号加一(v)，该报文段称为TCP连接释放报文段。客户端进入终止等待1(FIN_WAIT_1)状态

2. 服务端收到TCP连接释放报文段后，发送TCP 确认报文，ACK位置为1，序号为v，确认号为u+1。服务端进入关闭等待(CLOSE_WAIT)状态，表示客户端已经没有数据要发送了，但是服务端还有数据要发送(包括未确认的报文段)，客户端仍要接受

3. 客户端收到来自服务端的TCP 确认报文后进入终止等待2(FIN_WAIT_2)状态，等待服务端发出的TCP连接释放报文段。

   服务端发送TCP连接释放报文，FIN位与ACK位被置为1，序号为w(因为在发送TCP连接释放报文前，服务端可能还发送了一些数据)，确认号为u+1，对之前客户端的连接释放报文重复确认，服务端进入最后确认(LAST_ACK)状态

4. 客户端收到来自服务端的TCP连接释放报文后，发送确认报文，ACK位置为1，序号为u+1，确认号为w+1，客户端进入时间等待(TIME_WAIT)状态。服务端收到该确认报文后进入关闭状态，而客户端还要等待2MSL(最长报文段寿命)后关闭，资源被释放

#### TCP拥塞控制

发送方维护一个变量：拥塞窗口(congestion window，cwnd)，对发送方能向网络层发送的数据进行了限制。发送方中发送但未被确认的数据量不能超过rcwd和cwdn的最小值，即LastByteSent-LastByteAcked≤min{cwnd，cwnd}

##### TCP拥塞控制算法

1. 慢启动(Slow Start)

   cwnd的值以一个MSS开始，每当传输的报文段首次得到确认，cwnd就增加一个cwnd

   慢启动的三种结束方式

   + 由于超时而丢包，ssthresh(慢启动的阈值)被置为此时cwnd的一半，cwnd被重置为1个MSS，此时重新开始慢启动
   + cwnd达到或超过ssthresh，结束慢启动，进入拥塞避免模式
   + 收到三个冗余ACK，ssthresh被置为此时cwnd的一半，cwnd被重置为ssth+3个MSS，执行一次快速重传并转到快速恢复状态

2. 拥塞避免(Congestion Avoidance)

   每个RTT只会使cwnd增加1个MSS

   拥塞避免的两种结束方式

   + 由于超时而丢包，ssthresh被置为此时cwnd的一半，cwnd被重置为1个MSS，此时重新开始慢启动
   + 收到三个冗余ACK，ssthresh被置为此时cwnd的一半，cwnd被重置为ssth+3个MSS，执行一次快速重传并转到快速恢复状态

3. 快速重传(Fast Retransmit)

   当接收方收到了失序的分组，不会返回对失序分组的确认，而是返回冗余ACK(接收到的最后一个有序分组的确认)，并将确认号（期望收到的下一个报文段的序号）设置为有序的。

   当发送方收到了同样的三个冗余ACK，就不会等待计时器超时，而是直接重传，接收方收到快速重传的报文段后，返回对收到的最后一个有序分组的确认

4. 快速恢复(Fast Recovery)

   此时ssthresh为之前cwnd的一半，cwnd为这时的ssthresh+3

   当失序报文段的ACK到达时，进入拥塞避免状态

   当超时时，进入慢启动状态

   

## 网络层：数据平面

### IP协议

#### IPV4

IPV4数据报格式

## 网络层：控制平面

## 链路层